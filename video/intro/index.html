<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Framv — Intro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700;800&display=swap" rel="stylesheet" />
    <style>
      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        background: #000;
        font-family: "JetBrains Mono", monospace;
      }

      /* Video canvas: fixed 1920×1080, scaled to viewport */
      #framv-canvas {
        width: 1920px;
        height: 1080px;
        position: relative;
        overflow: hidden;
        background: #000;
        transform-origin: top left;
      }

      #framv-wrap {
        width: 100vw;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }

      /* Terminal grid overlay */
      .terminal-grid {
        position: absolute;
        inset: 0;
        pointer-events: none;
        background-image: linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
        background-size: 20px 20px;
        z-index: 0;
      }

      /* Sequence containers */
      .framv-sequence {
        position: absolute;
        inset: 0;
        display: none;
      }

      .framv-sequence.framv-active {
        display: block;
      }

      /* Scrubber controls */
      #framv-controls {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: rgba(0, 0, 0, 0.85);
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        padding: 8px 16px;
        display: flex;
        align-items: center;
        gap: 12px;
        font-family: "JetBrains Mono", monospace;
        font-size: 11px;
        color: rgba(255, 255, 255, 0.5);
        z-index: 100;
      }

      #framv-scrubber {
        flex: 1;
        accent-color: #ff79c6;
        cursor: pointer;
      }

      #framv-play-btn {
        background: none;
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: rgba(255, 255, 255, 0.7);
        padding: 2px 10px;
        cursor: pointer;
        font-family: inherit;
        font-size: 11px;
      }

      #framv-play-btn:hover {
        background: rgba(255, 255, 255, 0.05);
      }
    </style>
  </head>

  <body>
    <div id="framv-wrap">
      <div id="framv-canvas" data-fps="30" data-width="1920" data-height="1080">
        <div class="terminal-grid"></div>
        <!-- sequences injected here -->
      </div>
    </div>

    <div id="framv-controls">
      <button id="framv-play-btn">[ PLAY ]</button>
      <input id="framv-scrubber" type="range" min="0" max="0" value="0" step="1" />
      <span id="framv-frame-display">0 / 0</span>
      <span style="color: rgba(255, 120, 200, 0.7)">SPACE=play/pause</span>
    </div>

    <!-- @framv/player (workspace package, resolved via npm workspaces symlink) -->
    <script type="module">
      import { Player } from "../../packages/video/dist/index.js";

      // ─── sequence manifest ─────────────────────────────────────────────────────
      const SEQUENCES = [
        { src: "./sequences/00-hero.html", from: 0, duration: 90 },
        { src: "./sequences/01-features.html", from: 90, duration: 120 },
        { src: "./sequences/02-code.html", from: 210, duration: 120 },
        { src: "./sequences/03-cta.html", from: 330, duration: 60 },
      ];

      const canvas = document.getElementById("framv-canvas");
      const scrubber = document.getElementById("framv-scrubber");
      const frameDisplay = document.getElementById("framv-frame-display");
      const playBtn = document.getElementById("framv-play-btn");

      const fps = parseInt(canvas.dataset.fps) || 30;
      const totalFrames = SEQUENCES.reduce((max, s) => Math.max(max, s.from + s.duration), 0) - 1;
      const totalSeconds = totalFrames / fps;

      scrubber.max = totalFrames;

      let nodes = []; // { el, from, duration }

      // ─── scale canvas to viewport ─────────────────────────────────────────────
      function scaleCanvas() {
        const scaleX = window.innerWidth / 1920;
        const scaleY = (window.innerHeight - 44) / 1080;
        const scale = Math.min(scaleX, scaleY);
        canvas.style.transform = `scale(${scale})`;
        document.getElementById("framv-wrap").style.height = window.innerHeight - 44 + "px";
      }
      window.addEventListener("resize", scaleCanvas);
      scaleCanvas();

      // ─── sequence rendering ────────────────────────────────────────────────────
      function renderFrame(f) {
        const frame = Math.max(0, Math.min(Math.round(f), totalFrames));
        nodes.forEach(({ el, from, duration }) => {
          const active = frame >= from && frame < from + duration;
          el.classList.toggle("framv-active", active);
          if (active) {
            el.style.setProperty("--frame", frame - from);
            el.style.setProperty("--duration", duration);
          }
        });
        scrubber.value = frame;
        frameDisplay.textContent = frame + " / " + totalFrames;
      }

      // ─── load sequences ────────────────────────────────────────────────────────
      async function loadSequences() {
        for (const seq of SEQUENCES) {
          const res = await fetch(seq.src);
          const html = await res.text();
          const wrap = document.createElement("div");
          wrap.className = "framv-sequence";
          wrap.dataset.from = seq.from;
          wrap.dataset.duration = seq.duration;
          wrap.innerHTML = html;
          wrap.querySelectorAll("script").forEach((old) => {
            const s = document.createElement("script");
            s.textContent = old.textContent;
            old.replaceWith(s);
          });
          canvas.appendChild(wrap);
          nodes.push({ el: wrap, from: seq.from, duration: seq.duration });
        }
        renderFrame(0);
        initPlayer();
      }

      // ─── @framv/player integration ────────────────────────────────────────────
      function initPlayer() {
        const player = new Player(canvas);
        player.setDuration(totalSeconds);

        // Drive sequence switching and scrubber from player's timeupdate
        player.on("timeupdate", (t) => {
          renderFrame(t * fps);
        });

        player.on("play", () => {
          playBtn.textContent = "[ PAUSE ]";
        });

        player.on("pause", () => {
          playBtn.textContent = "[ PLAY ]";
        });

        player.on("ended", () => {
          playBtn.textContent = "[ PLAY ]";
        });

        // Controls
        playBtn.addEventListener("click", () => {
          player.playing ? player.pause() : player.play();
        });

        scrubber.addEventListener("input", async () => {
          player.pause();
          await player.seek(parseInt(scrubber.value) / fps);
        });

        document.addEventListener("keydown", async (e) => {
          if (e.code === "Space") {
            e.preventDefault();
            player.playing ? player.pause() : player.play();
          }
          if (e.code === "ArrowRight") {
            player.pause();
            await player.seek(player.currentTime + 1 / fps);
          }
          if (e.code === "ArrowLeft") {
            player.pause();
            await player.seek(player.currentTime - 1 / fps);
          }
        });

        // Expose for @framv/runner: window.framv.setFrame(f) and window.framv (exportElement)
        // The runner calls window.framv.setFrame to scrub to a specific frame before capture.
        window.setFramvFrame = async (f) => {
          player.pause();
          await player.seek(f / fps);
        };

        // Also expose a minimal window.framv for runner compatibility
        window.framv = {
          player,
          fps,
          get frame() {
            return Math.round(player.currentTime * fps);
          },
        };
      }

      loadSequences();
    </script>
  </body>
</html>
